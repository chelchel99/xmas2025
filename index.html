<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merry Christmas - AI Interactive</title>
    <style>
        body { margin: 0; background: #000; color: white; font-family: sans-serif; overflow: hidden; }
        #loader { position: fixed; inset: 0; background: #000; z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: opacity 1s; }
        .spinner { width: 40px; height: 40px; border: 3px solid rgba(212,175,55,0.3); border-top: 3px solid #d4af37; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .ui { position: fixed; inset: 0; pointer-events: none; z-index: 10; display: flex; flex-direction: column; align-items: center; justify-content: space-between; padding: 40px 0; }
        h1 { font-size: 2.5rem; text-shadow: 0 0 10px #d4af37; letter-spacing: 2px; }
        .hint { color: #888; font-size: 0.9rem; text-align: center; }
        video { position: fixed; bottom: 10px; right: 10px; width: 120px; height: 90px; border: 1px solid #d4af37; opacity: 0.3; transform: scaleX(-1); }
    </style>
</head>
<body>

<div id="loader">
    <div class="spinner"></div>
    <div style="color:#d4af37">魔法正在加載中...</div>
</div>

<div class="ui">
    <h1>Merry Christmas</h1>
    <div class="hint">對著鏡頭：握拳 (樹) · 張手 (散開)<br>移動手掌可以旋轉場景</div>
</div>

<video id="webcam" autoplay playsinline></video>

<script type="importmap">
{
    "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
        "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
    }
}
</script>

<script type="module">
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

let scene, camera, renderer, composer, mainGroup, handLandmarker;
let particles = [], state = { mode: 'TREE', rotX: 0, rotY: 0 };

async function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 50;

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    mainGroup = new THREE.Group();
    scene.add(mainGroup);

    scene.add(new THREE.AmbientLight(0xffffff, 1));
    
    composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.6, 0.4, 0.85));

    // 建立粒子
    const geo = new THREE.SphereGeometry(0.3, 8, 8);
    const gold = new THREE.MeshStandardMaterial({ color: 0xd4af37 });
    const red = new THREE.MeshStandardMaterial({ color: 0xaa0000 });
    
    for(let i=0; i<1000; i++) {
        const mesh = new THREE.Mesh(geo, i % 2 === 0 ? gold : red);
        const p = {
            mesh,
            target: new THREE.Vector3(),
            scatter: new THREE.Vector3().randomDirection().multiplyScalar(20 + Math.random()*10)
        };
        mainGroup.add(mesh);
        particles.push(p);
    }

    await setupAI();
    animate();
}

async function setupAI() {
    try {
        const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
            baseOptions: { 
                modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
                delegate: "GPU" 
            },
            runningMode: "VIDEO", numHands: 1
        });
        
        const video = document.getElementById('webcam');
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        video.srcObject = stream;
        video.onloadeddata = () => {
            document.getElementById('loader').style.opacity = '0';
            setTimeout(() => document.getElementById('loader').remove(), 1000);
        };
    } catch (e) {
        console.error("AI 載入失敗:", e);
        document.getElementById('loader').innerHTML = "<p>請確保允許使用相機並重新整理</p >";
    }
}

function animate() {
    requestAnimationFrame(animate);
    const video = document.getElementById('webcam');
    
    if (handLandmarker && video.readyState === 4) {
        const results = handLandmarker.detectForVideo(video, performance.now());
        if (results.landmarks && results.landmarks[0]) {
            const lm = results.landmarks[0];
            state.rotY = (lm[9].x - 0.5) * 3;
            state.rotX = (lm[9].y - 0.5) * 2;
            const dist = Math.hypot(lm[8].x - lm[0].x, lm[8].y - lm[0].y);
            state.mode = dist < 0.25 ? 'TREE' : 'SCATTER';
        }
    }

    mainGroup.rotation.y = THREE.MathUtils.lerp(mainGroup.rotation.y, state.rotY, 0.05);
    mainGroup.rotation.x = THREE.MathUtils.lerp(mainGroup.rotation.x, state.rotX, 0.05);

    particles.forEach((p, i) => {
        if (state.mode === 'TREE') {
            const t = i / particles.length;
            const r = 12 * (1 - t);
            const a = t * 50;
            p.target.set(Math.cos(a)*r, t*30-15, Math.sin(a)*r);
        } else {
            p.target.copy(p.scatter);
        }
        p.mesh.position.lerp(p.target, 0.05);
    });

    composer.render();
}

window.onload = init;
window.onresize = () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
};
</script>
</body>
</html>
